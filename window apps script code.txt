/***** CONFIG *****/
const SHEET_NAME = 'GlassStatus';
const EXPECTED_HEADERS = ['Train', 'Carriage', 'Glass', 'Status', 'Timestamp', 'Notes', 'RepairDate'];

/***** ENTRY POINTS *****/
function doGet(e) {
  try {
    const trainId = e.parameter.trainId;
    if (!trainId) throw new Error('Missing trainId parameter');

    const data = loadTrainData(trainId);
    return jsonOutput({ success: true, data });
  } catch (err) {
    return jsonOutput({ success: false, message: err.message });
  }
}

function doPost(e) {
  try {
    // Accept JSON or form-encoded payload
    let data;
    if (e.postData.type === 'application/json') {
      data = JSON.parse(e.postData.contents);
    } else {
      data = JSON.parse(e.parameter.payload); // form-urlencoded: payload=<jsonstring>
    }

    if (!data.trainId || !data.updates) {
      throw new Error('Missing required fields (trainId or updates)');
    }

    // Process individual updates
    saveIndividualUpdates(data);
    
    return jsonOutput({
      success: true,
      message: 'Updates saved successfully'
    });
  } catch (err) {
    return jsonOutput({
      success: false,
      message: err.message
    });
  }
}

/***** MAIN LOGIC *****/
function loadTrainData(trainId) {
  const sheet = getSheet();
  const rows = sheet.getDataRange().getValues();
  rows.shift(); // remove header row

  const trainData = { 
    trainId, 
    notes: '', 
    timestamp: '', 
    carriages: {} 
  };

  rows.forEach(row => {
    if (row[0] === trainId) {
      const carriageId = row[1];
      const glassId = row[2];
      const status = row[3];
      const timestamp = row[4];
      const notes = row[5];

      if (!trainData.carriages[carriageId]) {
        trainData.carriages[carriageId] = {};
      }
      trainData.carriages[carriageId][glassId] = status;

      // Keep the most recent notes and timestamp
      if (timestamp && (!trainData.timestamp || timestamp > trainData.timestamp)) {
        trainData.timestamp = timestamp;
        trainData.notes = notes || '';
      }
    }
  });

  return trainData;
}

function saveIndividualUpdates(data) {
  const sheet = getSheet();
  const timestamp = new Date().toISOString();

  // Save each individual update
  for (const [carriageId, glasses] of Object.entries(data.updates)) {
    for (const [glassId, update] of Object.entries(glasses)) {
      sheet.appendRow([
        data.trainId,
        carriageId,
        glassId,
        update.status,
        timestamp,
        data.notes || '',
        update.repairDate || ''
      ]);
    }
  }
}

/***** HELPERS *****/
function getSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(SHEET_NAME);

  if (!sheet) {
    sheet = ss.insertSheet(SHEET_NAME);
    sheet.getRange(1, 1, 1, EXPECTED_HEADERS.length).setValues([EXPECTED_HEADERS]);
  } else if (sheet.getLastRow() === 0) {
    sheet.getRange(1, 1, 1, EXPECTED_HEADERS.length).setValues([EXPECTED_HEADERS]);
  }

  return sheet;
}

function jsonOutput(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}